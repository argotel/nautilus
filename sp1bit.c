/*
 * The author of this software is William Dorsey.
 * Copyright (c) 1993, 1994, 1995 by William Dorsey.  All rights reserved.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, THE AUTHOR DOES NOT MAKE ANY CLAIM OR
 * WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS SOFTWARE OR
 * ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */

/*
 *  sp1bit.c -- coder based on switched prediction that produces 1
 *              bit per audio sample
 */

/* REVISION HISTORY
 *
 * SCCS ID: @(#)sp1bit.c 1.2 96/03/31
 *
 * DATE      RESPONSIBLE PARTY  DESCRIPTION
 * -------------------------------------------------------------------------
 * 93/05/13  B. Dorsey      	Wrote original version
 * 93/09/12  B. Dorsey		Changes for nautilus (no functional changes)
 * 93/09/16  R. Berry		Optimized encode()
 * 93/12/11  B. Dorsey		Modified to use fixed point arithmetic
 * 95/06/08  B. Dorsey		Renamed to sp64 from apsd
 * 95/06/25  J. A. Fingerhut	Merged both fixed point arithmetic and
 * 				floating point arithmetic versions of
 * 				SP64 and SP85 coders into one file.
 * 95/08/21  B. Dorsey		Added lowpass filter for sp85
 * 96/02/23  J. A. Fingerhut	Cleaned up code for clipping of samples.
 * 96/12/15  D. Milleri		Minor optimization in lowpass() initialization
 * 04/02/29  S. Wieseckel	fixed compiler warning
 */

#include <stdio.h>
#ifdef _WIN32
    #include <memory.h>
#endif
#ifdef UNIX	
    #include <string.h>
#endif


#include "machine.h"

//*
//* There will be several places in this file containing constructs
//* like this:
//* 
//* #ifdef FIXED_POINT_ARITHMETIC
//* 
//* ... some code for fixed point version ...
//* 
//* #else /* FIXED_POINT_ARITHMETIC * /
//* 
//* ... some code for floating point version ...
//* 
//* #endif /* FIXED_POINT_ARITHMETIC * /
//*                                  ^^^
//*                          Don't eliminate this blank.  I think you
//*                          can figure out why :-)
/* 
 * will be seen.  This same file is intended to be the source file for
 * both the fixed point version of the SP64 and SP85 speech coders,
 * and the floating point version.  This symbol is also used in the
 * header file fixfloat.h.
 * 
 * The preprocessor symbol AUDIO_DEVICE_8KHZ_ONLY is also used to
 * conditionally compile code, in this case for upsampling and
 * downsampling the signals.  This symbol should be defined when
 * compiling on Sun workstations whose audio devices can only sample
 * and play sound at 8000 samples/sec.
 *
 * Finally, there are the following symbols for choosing between the
 * SP64 and SP85 coders.  Here is how they should be defined.  A table
 * entry of (undefined) means that the symbol should not be defined at
 * all, and an entry of "" means that the symbol need only be defined;
 * the exact definition is unimportant.
 *
 * Preprocessor          Definition for    Definition for
 * symbol name           the SP64 coder    the SP85 coder
 * ---------------------------------------------------------
 * SP64                  ""                (undefined)
 * SP85                  (undefined)       ""
 * INIT_FUNC_NAME        sp64_init         sp85_init
 * ENCODE_FUNC_NAME      sp64_encode       sp85_encode
 * DECODE_FUNC_NAME      sp64_decode       sp85_decode
 */


#include "fixfloat.h"


/* Operating Parameters */

/* The number of voice samples to be encoded together. */
#define FRAME_SIZE      120
/* Precomputed value of sqrt(FRAME_SIZE-1). */
#define FSROOT		FLOAT2VALUE(10.9087)

#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
/*
 * The number of samples at 8000 samples/sec required to have the same
 * duration as FRAME_SIZE samples at 6000 samples/sec.  This is the
 * same as (FRAME_SIZE*8000/6000).
 */
#define IBLKSIZE	(FRAME_SIZE*4/3)
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */

/*
 * YPSIZE is the number of bits used to encode the step size.
 *
 * YPMIN and YPMAX are minimum and maximum step sizes to use in the
 * encoding.
 *
 * SLOPE_MULT is for ???
 */
#define YPSIZE          6
#define	YPMIN		FLOAT2VALUE(0.001)

#if defined(SP64)

#define YPMAX		FLOAT2VALUE(0.175)
#define	SLOPE_MULT	FLOAT2VALUE(0.800)

#elif defined(SP85)

#define YPMAX		FLOAT2VALUE(0.300)
#define	SLOPE_MULT	FLOAT2VALUE(1.000)

#endif /* defined(SP85) */


/*
 * The folowing FIR filter coefficients are for use with the sp85 coder.
 * Since the sp85 coder passes frequencies between 3KHZ and 4KHZ which
 * is outside the normal range of speech reproduction, it is advantageous
 * to filter out the quantization noise generated by the coder in this
 * region in order to improve the quality of the reproduced speech.
 * The following table details the characteristics of the filter:
 *
 *          Freq.   Value   Weight  Lower Lim. Upper Lim.  Deviation  Dev. dB
 *Band  1: 0.0000   1.00      4.0       ----       ----     0.12        0.98
 *         0.3688   1.00      4.0       ----       ----     0.12        0.98
 *Band  2: 0.4125     0.      5.0       ----       ----     0.10      -20.41
 *         0.5000     0.      5.0       ----       ----     0.10      -20.41
 */

#ifdef LOWPASS_FILTER
#define NTAPS		19	/* 19 taps for this filter */
value_t lpcofs[] = {
   FLOAT2VALUE( 3.280688E-02),  FLOAT2VALUE( 5.142615E-02),
   FLOAT2VALUE(-4.967840E-02),  FLOAT2VALUE( 4.390130E-02),
   FLOAT2VALUE(-1.961068E-02),  FLOAT2VALUE(-2.730027E-02),
   FLOAT2VALUE( 9.014270E-02),  FLOAT2VALUE(-1.542842E-01),
   FLOAT2VALUE( 2.023044E-01),  FLOAT2VALUE( 7.798845E-01),
   FLOAT2VALUE( 2.023044E-01),  FLOAT2VALUE(-1.542842E-01),
   FLOAT2VALUE( 9.014270E-02),  FLOAT2VALUE(-2.730027E-02),
   FLOAT2VALUE(-1.961068E-02),  FLOAT2VALUE( 4.390130E-02),
   FLOAT2VALUE(-4.967840E-02),  FLOAT2VALUE( 5.142615E-02),
   FLOAT2VALUE( 3.280688E-02)
};
#endif /* LOWPASS_FILTER */


/*
 * While compressing a frame, y[0] and y[1] contain the previous two
 * values that were estimated by the linear prediction filter (y[0] is
 * the most recent, y[1] is the one before that).  These values are
 * initialized in INIT_FUNC_NAME(), and changed in the
 * ENCODE_FUNC_NAME() and DECODE_FUNC_NAME() functions.  When sending
 * or receiving multiple frames in sequence, their values are
 * maintained from one frame to the next.  This could be a problem if
 * a packet is lost during transmission, because the receiver's state
 * could become out of sync with the sender's state.  Would it be a
 * good idea to reinitialize them at the beginning of each frame in
 * both ENCODE_FUNC_NAME() and DECODE_FUNC_NAME() for this reason?
 *
 * ypdelta is a value computed once in INIT_FUNC_NAME().  It is the
 * difference between each consecutive pair of quantized values of the
 * step_size parameter.
 */

static struct coder_state_t {
    value_t           y[2];
#ifdef LOWPASS_FILTER
    value_t           ry[NTAPS-1];
#endif
    value_t           ypdelta;
} handle;


/*
 * These values are filter coefficients used to predict a "good guess"
 * value for the next sample based on the value of the previous two
 * samples.  There are 4 sets of filter coefficients, one set for each
 * of the 4 states of the coder.  These values can be found on p. 301
 * of [Jayant and Noll, 1984], where they cite [Evci, Xydeas, and
 * Steele, 1981] as the source.
 */

static struct ifilter_t {
    value_t           h1;
    value_t           h2;
} filters[] = {	/* filter coefficients */
#if defined(SP85)
    { FLOAT2VALUE( 1.32), FLOAT2VALUE(-0.43) },
    { FLOAT2VALUE( 0.95), FLOAT2VALUE(-0.27) },
    { FLOAT2VALUE( 0.50), FLOAT2VALUE(-0.08) },
    { FLOAT2VALUE( 0.15), FLOAT2VALUE( 0.06) }
#else
    { FLOAT2VALUE( 1.53), FLOAT2VALUE(-0.72) },
    { FLOAT2VALUE( 0.95), FLOAT2VALUE(-0.34) },
    { FLOAT2VALUE( 0.48), FLOAT2VALUE(-0.21) },
    { FLOAT2VALUE(-0.63), FLOAT2VALUE(-0.36) }
#endif
};


#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
void downsample(float *x, int nx, float *y);
void upsample(float *x, int nx, float *y);
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */
#ifdef LOWPASS_FILTER
void lowpass(value_t *x, value_t *ry);
#endif



void
INIT_FUNC_NAME(void)
{
#ifdef LOWPASS_FILTER
    int i;
#endif

    /* initializations */
    handle.y[0] = FLOAT2VALUE(0.0);
    handle.y[1] = FLOAT2VALUE(0.0);
#ifdef LOWPASS_FILTER
    for (i=0; i<NTAPS-1; i++)
    	handle.ry[i] = FLOAT2VALUE(0.0);
#endif

    /*
     * The step size transmitted over the modem is represented in
     * YPSIZE bits, and it represents a value in the range [YPMIN,
     * YPMAX].  A bit pattern of all 0's is used to represent YPMIN,
     * and all 1's represents YPMAX.  The intermediate values
     * represent evenly spaced values in the interval [YPMIN, YPMAX].
     * ypdelta is the difference between two consecutive such values.
     */
    handle.ypdelta = DIV(YPMAX - YPMIN, FLOAT2VALUE((float) ((1L << YPSIZE) - 1)) );
}



void
ENCODE_FUNC_NAME(INT16 *x, UINT8 *bits)
{
    int             i;		/* generic loop variable */
    int             state;	/* one of 4 states of the switched
				   predictor */
    int             step;	/* the quantized step size to use for
				   the differential coding */
    int             next_bit;	/* the next bit to send to the
				   receiver in the differential coding */
    value_t         phi0;	/* the autocorrelation of the frame of
				   samples at lag 0 */
    value_t         phi1;	/* the autocorrelation of the frame of
				   samples at lag 1 */
    value_t         step_size;	/* First used as the un-quantized step
				   size, and then later the quantized
				   step size represented in type
				   value_t. */
    value_t         y;		/* First used as a generic computation
				   variable, then later as the sample
				   value predicted by the 2nd order
				   linear predictor. */
    value_t         yy;		/* Generic computation variable. */
    value_t         xr[FRAME_SIZE];	/* The input samples after
					   possible resampling, and
					   then conversion to type
					   value_t. */
    UINT8           mask;	/* The next bit position within the
				   variable data to place the next
				   encoded bit. */
    UINT8           data;	/* The contents of the next byte to
				   place in the compressed output. */
    int             next_byte_pos;	/* The next position in the
					   output array bits to
					   fill. */

#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
    /*
     * If downsampling is needed, define a buffer to hold the data
     * after conversion from standard form to type value_t, but before
     * downsampling.
     */
    value_t         xf[IBLKSIZE];
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */

#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
    /*
     * NOTE: The following code assumes that if AUDIO_DEVICE_8KHZ_ONLY
     * is defined, then we must also be using floating point
     * arithmetic, i.e., FIXED_POINT_ARITHMETIC is not defined.  This
     * is true as of version 0.9.2 of Nautilus, but might not be true
     * in the future.  At such a time, this code would need to be
     * changed.
     * 
     * On a Sun, the audio input device can only sample at 8000
     * samples/sec.  The SP64 speech coder expects speech input
     * sampled at 6000 samples/sec.  Resample the input at the
     * desired rate.
     */

    /* convert input to floating point */
    for (i = 0; i < IBLKSIZE; i++) {
	xf[i] = audio_s2f(x[i]);
    }

    /* resample input */
    downsample(xf, IBLKSIZE, xr);
#else /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */
    /*
     * On other platforms (e.g., MS-DOS and Intel Linux), we expect
     * the incoming speech samples to already be at (or very near)
     * 6000 samples/sec for the SP64 coder.  Only conversion from
     * standard samples to the samples needed by the coder is
     * necessary.
     *
     * For the SP85 coder, no resampling is necessary on any platform,
     * because the incoming samples are expected to be 8000
     * samples/sec.
     */
    for (i = 0; i < FRAME_SIZE; i++) {
	xr[i] = (float) audio_s2f(x[i]);
    }
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */

    /*
     * Compute normalized autocorrelation at lag 0 & 1.
     * Compute step size based on RMS value
     */
    yy = xr[0];					/* priming the loop */
    phi0 = MUL(yy, yy) + FLOAT2VALUE(1.0e-20);	/* +1.0e-20 to prevent divide by 0 */
    step_size = phi1 = FLOAT2VALUE(0.0);

    for (i = 1; i < FRAME_SIZE; i++) {
	y = xr[i];
	phi0 += MUL(y, y);			/* autocorr at lag 0 */
	phi1 += MUL(yy, y);			/* autocorr at lag 1 */
	step_size += MUL(y - yy, y - yy);	/* rms calc */
	yy = y;
    }

    /*
     * At this time, the following is true:
     *
     * xr[0..(FRAME_SIZE-1)] = FRAME_SIZE samples at 6000 samples/sec,
     *                         where each sample is either a fixed point
     *                         or floating point value in the range
     *                         [-1, +1].
     * phi0 = sum from i=0 to (FRAME_SIZE-1) of xr[i]^2    (plus 1.0e-20)
     * phi1 = sum from i=1 to (FRAME_SIZE-1) of (xr[i]*xr[i-1])
     * step_size = sum from i=1 to (FRAME_SIZE-1) of (xr[i]-xr[i-1])^2
     *
     * This formula for step_size is algebraically equivalent to:
     *
     * = sum from i=1 to (FRAME_SIZE-1) of (xr[i]^2 + xr[i-1]^2
     *                                         - 2 * xr[i] * xr[i-1])
     *
     * = ( sum from i=1 to (FRAME_SIZE-1) of 2 * (xr[i]^2 - xr[i] * xr[i-1]) )
     *       - ( xr[0]^2 + xr[FRAME_SIZE-1]^2 )
     *
     * = 2 * phi0 - 2 * phi1 - ( 3 * xr[0]^2 + xr[FRAME_SIZE-1]^2 )
     *
     * Thus it seems that one could remove the computation for step_size
     * from within the loop above, and simply make the following assignment
     * afterwards:
     *
     * step_size = MUL( INT2VALUE(2), phi0 - phi1 );
     *
     * (This is probably close enough to the value computed above, but
     * if not, it would be easy to add in the
     * -(3*xr[0]^2 + xr[FRAME_SIZE-1]^2) term.)
     *
     * Note that it might still be worth computing step_size as in the
     * code above, because even though it is algebraically equivalent
     * to the formula above, the way it is computed may have better
     * numerical properties (e.g., overflow, underflow, roundoff
     * error).
     */

    phi1 = DIV(phi1, phi0);			/* normalize phi1 */

    /* select predictor state */
#if defined(SP85)
	state =
		phi1 > FLOAT2VALUE(0.85) ? 0 :
		phi1 > FLOAT2VALUE(0.60) ? 1 :
		phi1 > FLOAT2VALUE(0.30) ? 2 :
		3;
#else
	state =
		phi1 > FLOAT2VALUE(0.70) ? 0 :
		phi1 > FLOAT2VALUE(0.40) ? 1 :
		phi1 > FLOAT2VALUE(0.00) ? 2 :
		3;
#endif

    /* compute step sized based on RMS value of input */

    /*
     * I thought that the root-mean-square was algebraically defined
     * as:
     *
     * sqrt ( ( sum from i=0 to (FRAME_SIZE-1) of xr[i]^2 ) / FRAME_SIZE )
     *
     * Given how step_size is computed above, this is clearly not the
     * same.  Are the comments wrong, or is my idea of the definition
     * root-mean-square wrong?  (Perhaps there is more than one kind
     * of RMS?)
     */

    step_size = (float) SQRT(step_size);
    step_size = DIV(step_size, FSROOT);
    step_size = MUL(SLOPE_MULT, step_size);

    /*
     * Quantize step_size to YPSIZE bits and store in step.  Then
     * convert the quantized value back into step_size so that the
     * coder is using the same value for compression that the decoder
     * will be using for decompression.
     */

    /* check step size for bounds */
    if (step_size < YPMIN) {
	step_size = YPMIN;
    } else if (step_size > YPMAX) {
	step_size = YPMAX;
    }
    step = VALUE2INT( DIV(step_size - YPMIN, handle.ypdelta) );
    step_size = YPMIN + MUL( INT2VALUE(step), handle.ypdelta);

    /* save predictor state and quantized step size in output */
    bits[0] = state + (step << 2);

    /*
     * The first compressed output bit will be the most significant
     * bit of the byte, so initialize mask to 0x80.  The next byte of
     * compressed data is initially 0, and the desired bits will be
     * turned on below.
     */
    mask = 0x80;
    data = 0;
    next_byte_pos = 1;

    /* compute output bits */
    for (i = 0; i < FRAME_SIZE; i++) {

	/* apply linear predictive filter */
	y = MUL(filters[state].h1, handle.y[0]) +
	    MUL(filters[state].h2, handle.y[1]);

	handle.y[1] = handle.y[0];

	if (xr[i] > y) {
	    y += step_size;
#ifdef CLIP
	    if (y > FLOAT2VALUE(1.0)) {
	        y = FLOAT2VALUE(1.0);
	    }
#endif  /* CLIP */
	    next_bit = 1;
	}
	else {
	    y -= step_size;
#ifdef CLIP
	    if (y < FLOAT2VALUE(-1.0)) {
	        y = FLOAT2VALUE(-1.0);
	    }
#endif  /* CLIP */
	    next_bit = 0;
	}

	/* Turn on the next bit of output data, if necessary. */
	if (next_bit == 1) {
	    data |= mask;
	}
	/*
	 * If the byte data is full, determined by mask becoming 0,
	 * then add the byte to the output array bits, and
	 * reinitialize data and mask for the next output byte.
	 */
	mask >>= 1;
	if (mask == 0) {
	    bits[next_byte_pos] = data;
	    ++next_byte_pos;
	    data = mask;
	    mask = 0x80;
	}

	handle.y[0] = y;
    }
}



void
DECODE_FUNC_NAME(UINT8 * bits, INT16 * x)
{
    int             i;		/* generic loop variable */
    int             state;	/* one of 4 states of the switched
				   predictor */
    int             step;	/* the quantized step size to use for
				   the differential coding */
    value_t         step_size;	/* the quantized step size represented
				   in type value_t. */
    value_t         y;		/* The decoded sample value */
    value_t         xr[FRAME_SIZE];	/* The decoded frame of
					   samples before possible
					   resampling, and before
					   conversion to standard
					   samples */
#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
    /*
     * If upsampling is needed, define a buffer to hold the upsampled
     * data before conversion to standard samples.
     */
    value_t         xf[IBLKSIZE];
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */

    /* get predictor state and step size from input */
    state = bits[0] & 0x3;	/* least significant 2 bits */
    step = bits[0] >> 2;	/*  most significant 6 bits */

    /* decode step_size from quantized step size */
    step_size = YPMIN + MUL(INT2VALUE(step), handle.ypdelta);

    /*
     * Skip to the second byte of input, so that the array accesses
     * below will be correct.
     */
    bits = &bits[1];

    /* compute output from input bits */
    for (i = 0; i < FRAME_SIZE; i++) {

	/* apply linear predictive filter */
	y = MUL(filters[state].h1, handle.y[0]) +
	    MUL(filters[state].h2, handle.y[1]);

	handle.y[1] = handle.y[0];

	/*
	 * The following cryptic looking line isn't really too
	 * complex.  bits[i >> 3] is the byte of input data that
	 * contains the next desired bit.  i >> 3 equals i / 8 (at
	 * least for nonnegative i, which is all we care about here).
	 * (i & 7) equals i % 8, and (0x80 >> (i & 7)) is a bit mask
	 * that contains a 1 only in the bit position of the desired
	 * bit.
	 */
	if (bits[i >> 3] & (0x80 >> (i & 7))) {		/* Mycal's suggestion */
	    y += step_size;
#ifdef CLIP
	    if (y > FLOAT2VALUE(1.0)) {
	        y = FLOAT2VALUE(1.0);
	    }
#endif  /* CLIP */
	}
	else {
	    y -= step_size;
#ifdef CLIP
	    if (y < FLOAT2VALUE(-1.0)) {
	        y = FLOAT2VALUE(-1.0);
	    }
#endif  /* CLIP */
	}

	/* save output */
	handle.y[0] = y;
	xr[i] = y;
    }

#if defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY)
    /*
     * NOTE: The following code assumes that if AUDIO_DEVICE_8KHZ_ONLY
     * is defined, then we must also be using floating point
     * arithmetic, i.e., FIXED_POINT_ARITHMETIC is not defined.  This
     * is true as version 0.9.2 of Nautilus, but might not be true in
     * the future.  At such a time, this code would need to be
     * changed.
     * 
     * On a Sun, the audio output device can only play sound sampled
     * at 8000 samples/sec.  The SP64 speech decoder produces speech
     * sampled at 6000 samples/sec.  Resample the output at the
     * desired rate.
     */
    upsample(xr, FRAME_SIZE, xf);

    /* convert output to 16-bit signed linear format */
    for (i = 0; i < IBLKSIZE; i++) {
	x[i] = audio_f2s(xf[i]);
    }
#else /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */
    /*
     * If LOWPASS_FILTER is defined, invoke the lowpass filter function
     * to attenuate samples above approximately 3KHZ.
     */
#ifdef LOWPASS_FILTER
    lowpass(xr, handle.ry);
#endif

    /*
     * On other platforms (e.g., MS-DOS and Intel Linux), it is
     * acceptable for the resulting speech samples produced by this
     * function to be at 6000 samples/sec, because the sound card can
     * play at (or very near) this rate.  Only conversion from the
     * samples used by this coder to standard samples is necessary.
     *
     * For the SP85 coder, no resampling is necessary on any platform,
     * because the outgoing samples should be played at 8000
     * samples/sec.
     *
     */
    for (i = 0; i < FRAME_SIZE; i++) {
	x[i] = audio_f2s(xr[i]);
    }
#endif /* defined(SP64) && defined(AUDIO_DEVICE_8KHZ_ONLY) */
}

#ifdef LOWPASS_FILTER
/*
 * Lowpass filter function.  This function only works with FIR
 * filter coefficients that are symmetrical and have an odd-number
 * of points (which is what most zero-phase FIR filters are).
 * This particular function uses the predefined array lpcofs[NTAPS]
 * as the source of the coefficients.  It operates on FRAME_SIZE
 * points at a time and stores the rollover terms (from past the end
 * of the output data) in the ry array so that they can be summed
 * into the output on the next call to lowpass().
 */

void
lowpass(value_t *x, value_t *ry)
{
    int i, j;
    value_t yy;
    value_t y[FRAME_SIZE+NTAPS-1];

    /* Sum previous rollover terms into current output */
    for (i=0; i<NTAPS-1; i++) {
    	y[i] = ry[i];
    }

    /* Initialize memory */
    memset(&(y[NTAPS-1]), 0, (FRAME_SIZE) * sizeof(value_t));

    for (i=0; i<FRAME_SIZE; i++) {
    	/*
    	 * Compute NTAPS/2 intermediate terms and sum them
    	 * into the output.
    	 */
    	for (j=0; j<NTAPS/2; j++) {
    	    yy = MUL(lpcofs[j], x[i]);
	    y[i+j] += yy;
	    y[i+NTAPS-j-1] += yy;
	}
	y[i+NTAPS/2] += MUL(lpcofs[NTAPS/2], x[i]);
    }

    /*
     * Copy the filtered output back onto the input and copy
     * the rollover terms into the ry array.
     */
    memcpy((char *) x, (char *) y, FRAME_SIZE * sizeof(value_t));
    memcpy((char *) ry, (char *) &y[FRAME_SIZE], (NTAPS-1) * sizeof(value_t));
}
#endif
